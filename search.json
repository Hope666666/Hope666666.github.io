[{"title":"ABC356F","url":"/%E6%9D%82%E9%A2%98/AT-abc356-f/","content":"明显可以分别二分往  两边跳的答案。二分的 Check 可以通过区间询问差距的最大值是否超过  来判断。\n而对于区间的询问，使用线段树，先离线从小到大分配线段树每个叶子对应哪个数，修改结点时把线段树叶子上的布尔标记取反，难点就只剩 pushup 了。\nnode pushup(node x,node y){\tnode ans={x.tot+y.tot,0,0,0};\tif(x.tot==0||y.tot==0)//如果有一边没有节点，则直接用另一边\t{\t\tif(x.tot==0)ans.res=y.res;\t\telse if(y.tot==0)ans.res=x.res;\t}\telse ans.res=max(max(x.res,y.res),abs(x.rnum-y.lnum));//用两段答案和中间更新最大值\tif(x.tot==0)ans.lnum=y.lnum;\telse ans.lnum=x.lnum;\tif(y.tot==0)ans.rnum=x.rnum;\telse ans.rnum=y.rnum;\treturn ans;}\n\nCode#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N=2e5+5;int q,k;struct node{\tint tot,res,lnum,rnum;};unordered_map&lt;long long,int&gt;id;struct que{\tint op,x,idx;}t[N];bool cmp1(que x,que y){\treturn x.x&lt;y.x;}bool cmp2(que x,que y){\treturn x.idx&lt;y.idx;}struct tree{\t#define lson l,mid,num&lt;&lt;1\t#define rson mid+1,r,num&lt;&lt;1|1\t#define get_mid int mid=(l+r)&gt;&gt;1\tnode a[N&lt;&lt;2];\tnode pushup(node x,node y)\t{\t\tnode ans={x.tot+y.tot,0,0,0};\t\tif(x.tot==0||y.tot==0)\t\t{\t\t\tif(x.tot==0)ans.res=y.res;\t\t\telse if(y.tot==0)ans.res=x.res;\t\t}\t\telse ans.res=max(max(x.res,y.res),abs(x.rnum-y.lnum));\t\tif(x.tot==0)ans.lnum=y.lnum;\t\telse ans.lnum=x.lnum;\t\tif(y.tot==0)ans.rnum=x.rnum;\t\telse ans.rnum=y.rnum;\t\treturn ans;\t}\tvoid build(int l,int r,int num)\t{\t\tif(l==r)\t\t{\t\t\ta[num]={0,0,0,0};\t\t\treturn;\t\t}\t\tget_mid;\t\tbuild(lson),build(rson);\t\ta[num]=pushup(a[num&lt;&lt;1],a[num&lt;&lt;1|1]);\t}\tvoid update(int pos,int x,int l,int r,int num)\t{\t\tif(l==r&amp;&amp;l==pos)\t\t{\t\t\ta[num]={!a[num].tot,0,x,x};\t\t\treturn;\t\t}\t\tget_mid;\t\tif(pos&lt;=mid)update(pos,x,lson);\t\tif(pos&gt;mid)update(pos,x,rson);\t\ta[num]=pushup(a[num&lt;&lt;1],a[num&lt;&lt;1|1]);\t}\tnode query(int L,int R,int l,int r,int num)\t{\t\tif(L&lt;=l&amp;&amp;r&lt;=R)return a[num];\t\tget_mid;\t\tif(L&lt;=mid&amp;&amp;R&gt;mid)return pushup(query(L,R,lson),query(L,R,rson));\t\tif(L&lt;=mid)return query(L,R,lson);\t\tif(R&gt;mid)return query(L,R,rson);\t}}tr;signed main(){\tcin&gt;&gt;q&gt;&gt;k;\tint tot=0;\tfor(int i=1;i&lt;=q;i++)\t{\t\tcin&gt;&gt;t[i].op&gt;&gt;t[i].x;\t\tt[i].idx=i;\t}\tsort(t+1,t+1+q,cmp1);\tfor(int i=1;i&lt;=q;i++)\t{\t\tif(t[i].op==2)continue;\t\tif(!id.count(t[i].x))id[t[i].x]=++tot;\t}\tsort(t+1,t+1+q,cmp2);\ttr.build(1,tot,1);\tfor(int i=1;i&lt;=q;i++)\t{\t\tif(t[i].op==1)tr.update(id[t[i].x],t[i].x,1,tot,1);\t\telse\t\t{\t\t\tint ans1=0,ans2=0,l=id[t[i].x],r=tot;\t\t\twhile(l&lt;=r)\t\t\t{\t\t\t\tint mid=l+r&gt;&gt;1;\t\t\t\tnode tt=tr.query(id[t[i].x],mid,1,tot,1);\t\t\t\tif(tt.res&lt;=k)\t\t\t\t{\t\t\t\t\tans1=tt.tot;\t\t\t\t\tl=mid+1;\t\t\t\t}\t\t\t\telse r=mid-1;\t\t\t}\t\t\tl=1,r=id[t[i].x];\t\t\twhile(l&lt;=r)\t\t\t{\t\t\t\tint mid=l+r&gt;&gt;1;\t\t\t\tnode tt=tr.query(mid,id[t[i].x],1,tot,1);\t\t\t\tif(tt.res&lt;=k)\t\t\t\t{\t\t\t\t\tans2=tt.tot;\t\t\t\t\tr=mid-1;\t\t\t\t}\t\t\t\telse l=mid+1;\t\t\t}\t\t\tcout&lt;&lt;ans1+ans2-1&lt;&lt;endl;\t\t}\t}}","categories":["杂题"],"tags":["SegmentTree","Binary Search"]},{"title":"AGC032E","url":"/%E6%9D%82%E9%A2%98/AT-agc032-e/","content":"Statement把  从小到大排序，对一个二元组建边。\n对于二元组 ：\n若 ，染成蓝色。\n若 ，染成红色。\n考虑染色的最优情况，发现：\n\n存在一个分界点，使得它没有跨越它的线段。\n\n分界点的左右两边分别是蓝色和红色。\n\n分界点两边的线全都各自满足包含关系，即 。\n即\n\n\n\n考虑如何证明：\n注意到建边有如下几种情况\n\n我们可以用右  来作为例子：\n\n令线  的权值为 ，线  的权值为 。\n因为 ，所以这种情况的权值较大值为 。\n考虑调整后的情况，因为线  变成了 ，而 ，所以线还是蓝色的。\n因为线  变成了 ，而 ，所以线还是红色的。\n接下来证明权值较大值不会变得更大：\n考虑线 ，其权值为 。\n考虑线 ，其权值为 。\n所以权值都不会变得更大，证毕。\n\n其他 case 类似证明即可。\n然后找这个分界点。二分即可分界点越往左越优，思考一下只需要判分界点右边是不是都是红的就好了。\n时间复杂度  .\nSubmission\n    Code \n    \n      #include&lt;bits/stdc++.h&gt;#define int long long#define ll long long#define umap unordered_map#define pr pair#define st first#define nd second#define pc putchar#define pb push_back#define rep(i,x,y)for(int i=x;i&lt;=y;i++)#define per(i,x,y)for(int i=y;i&gt;=x;i--)#define ws(x) (write(x),pc(' '))#define we(x) (write(x),pc('\\n'))using namespace std;const int N=4e5,M=1e5,mod=998244353/*1e9+7*/,INF=LONG_LONG_MAX;inline void read(register int &amp;a){    a=0;register char c;    register int f=1;    while((c=getchar())&lt;48)if(c==45)f=-1;    do a=(a&lt;&lt;3)+(a&lt;&lt;1)+(c^48);    while((c=getchar())&gt;47);    a*=f;}inline void write(register int x){    if(x&lt;0)putchar('-'),x=-x;    if(x&gt;9)write(x/10);    putchar(x%10+'0');}int n,m,a[N+5],ans=INF;bool check(int x){    int maxn=0;    rep(i,1,x)maxn=max(maxn,a[i]+a[2*x-i+1]);    rep(i,1,n-x)    {        int tmp=a[2*x+i]+a[2*n-i+1];        if(tmp&lt;m)return 0;        maxn=max(maxn,tmp-m);    }    ans=min(ans,maxn);    return 1;}signed main(){    read(n),read(m);    rep(i,1,n*2)read(a[i]);    sort(a+1,a+1+n*2);    int l=0,r=n;    while(l&lt;=r)    {        int mid=l+r&gt;&gt;1;        if(check(mid))r=mid-1;        else l=mid+1;    }    we(ans);    return 0;}\n\n    \n  ","categories":["杂题"],"tags":["Binary Search","Greedy"]},{"title":"CF1443E","url":"/%E8%81%94%E8%80%83/CF1443E/","content":"Statement糖题，考虑到 ，所以只有最后  个数会变，暴力康托展开即可。\nSubmission\n    Code \n    \n      #include&lt;bits/stdc++.h&gt;#define int long long#define ll long long#define umap unordered_map#define pr pair#define st first#define nd second#define pc putchar#define pb push_back#define rep(i,x,y)for(int i=x;i&lt;=y;i++)#define per(i,x,y)for(int i=y;i&gt;=x;i--)#define ws(x) (write(x),pc(' '))#define we(x) (write(x),pc('\\n'))using namespace std;const int N=1e5,M=1e5,mod=998244353/*1e9+7*/,INF=INT_MAX;inline void read(register int &amp;a){    a=0;register char c;    register int f=1;    while((c=getchar())&lt;48)if(c==45)f=-1;    do a=(a&lt;&lt;3)+(a&lt;&lt;1)+(c^48);    while((c=getchar())&gt;47);    a*=f;}inline void write(register int x){    if(x&lt;0)putchar('-'),x=-x;    if(x&gt;9)write(x/10);    putchar(x%10+'0');}int n,q;vector&lt;int&gt;fac;void init(){    fac.pb(1);    while(fac[fac.size()-1]&lt;1e15)        fac.pb(fac[fac.size()-1]*(fac.size()+1));}int cnt=0;int endp[18];void upd(int x){    cnt+=x;    set&lt;int&gt;s;    per(i,0,min(n-1,(int)16))    {        int num=(cnt%fac[i])/fac[i-1];        rep(j,0,num)if(s.count(j))++num;        s.insert(num);        ++num;        num+=max(n-17,(int)0);        endp[i]=num;    }}void solve(){    int op;    read(op);    if(op==1)    {        int l,r;        read(l),read(r);        if(l&lt;=n-16)        {         //   return;            int ans=0;            if(r&gt;n-16)            {                for(int i=n-15;i&lt;=r;i++)ans+=endp[n-i];                ans+=(l+(n-16))*(n-15-l)/2;                we(ans);            }            else            {                ans+=(l+r)*(r-l+1)/2;                we(ans);            }        }        else        {          //  return;            int ans=0;            rep(i,l,r)ans+=endp[n-i];            we(ans);        }    }    else    {     //   return;        int x;        read(x);        upd(x);    }}signed main(){//  freopen(\"wsx.in\",\"r\",stdin);//  freopen(\"wsx.out\",\"w\",stdout);    init();    read(n),read(q);    upd(0);    while(q--)solve();}\n    \n  ","categories":["联考"],"tags":["Ad-hoc","Math"]},{"title":"Hello World","url":"/uncategorized/hello-world/","content":"\n\n  a5982b6be8cbb80de6cc1a3873a999357e172e1c6426d9792ce47f90c6aee8d851ca8dcfb87200929a868a2f9d018a4fe4b7e3fbf9608b3dffa9ca78b08dce3b08f6fb3798ece886abb38f9f126f8387eef3313f7da5cd5c4afaf6a51b623c9b8a8727d1f869011c352bc2ef76556d7e8c83931a3dafcb6dea67472c5b6b61b5bf1e8190538fd03bc59bb65c9666e211d8d1495764b2034f1b630e48b9a1be30f8c08810dee2dfa45a6c7b8efc2591e29f772ac6be5e76f9109ef5e462c77b53628cb3968aee45c1313ead64824b6c86e1135f5ceafc772f5d7a6e854a0af871108ecd4e74bf50a83aeef3cde03e4c300b2bb882cca2425ce5a47a5b0d8d24c49c39214525bd1c852d6a9cc266915e8ccc70070ab6339094512f3886418aae52ff77299fc4791a3b1956696f71c4b659be99ad072fb0c5e325ebd22af46af9e4178c80b5285f009f0d8f1b951671e8555fe7554363cfa1120aff88eeba625414f832db18aee4d3288b5a62f1f458f12ca9e0c7c510f8d7cbdcd059e1b46bd854a9a78a8f1126b83565dd94534503ff9d7747458d8c132cf91a8db66c9864a926e6d74b37d318c165b29dd31605e27435250b52a088b7ca1fcf1e8d310255eb0eaa43e31d25d46221d51babaefd00ee700f375f663c0c25139bb70ae7dca7471df1690a648272eb00612f29dc960d19628d5ce6d1face2f5acc00a53130f1a45b99f1a668903254cf508b7b3f514a41692f0438f3f37f02eb86be397c3e74985931b811f93169400aa56382dd6f97d20541b46cc453e90fdbc94f3c6650ede148985e40b50d83107612e03aef294292e844fd7156b9b2260cccea7f7cd490f11049f95b103db8132eecada4cc2383ab0a1f9510901844ccc37cbdd03e9f01711c65106ad5c81bd7f15b9cd607a0e21e62f420473798af76d4ed779e08e0eeebb3d9d1471b0ec40e14bf8c47d4244c4676f54f3c7dace943976c254bddce08a35262588ee8f720de6d2c21cf7dabf585090e0d163b0508341fd57e0e58c464873135efd1b0fa98d40d2b04ffc50e51876fb448c5a9cc26bb5d73b1a1613b37dd640cd0d3dc76bf34c417393dbba6bd84bb8fc6e0165d81f2bac7f4fedf347f81613d07e9163cdb34d6ddea7f71a611ffbfd78898577c23a3aba1e1ba1ebba663666fbc1fcc383ddd88c930a661443eeb03c6bf42935f888224b9b1fb97a69d599ae322c75898c725f7fea0e0b61319d89c236bd4f907811f2bfbee35db6d05486ef4b5b54ded9ba40bc97281081591f74f94951583212ad6539eb6fbcf9fb9a197537489a99af93bf6cf9216e53577009365aaf0ec34c97a0893834ef1a5088d14ea429d98a8493724bcbaef040699c6bcd6d121b98fd8a19a69aab3720e01414ce580d46765afdb64811bfee74d91f6f272b4eeb3e72f85d562c3fef3a9f49067bb5ad9c5c5d30eca879eeb397d7068fc3e29581a859d172c849a16182c9a8fd468bacca3fd00c9b91097ab48a55af132bccb590ff099e3269feeb9a6d312307da3802946e119178c0459b8e6d4744e0a2bdefdb9f82b7cba882b8f17260774815858c42805d5369729d504f576b919c257d791678ec8f4396a24d386fcf3f8b01ec7a97a3aa3a236340efa418b4742d377d225caee1ef85f5a11cf10a41c6d75945eea1d12e6accdcd1573b98d880203b5c70dabe8f6fdedf59dfb4534e84a0a84b1a224b7cb7ab64e95651f6490796190c756a5a914403cd24f986dce04a5315b7a1b9b3fd0c0daafcc174fdc5c82ffe57845dda4d17c0d83d7f896d80a0c317c02f45b6716d9255b84d9370d1fc89338c1c05bc22d763ca45db3d2cfe73884fdb3482b700375e76e19de45019cbc2264c54bcf07ced0136d93472acbc7d0886f2982b4e60e0d90b4e7457f5c605bc19c66bb7fee2252a4ff02899cac3d324d8d969d497248fd85a0ea42c411311265acbc68ffd4cf4ee92e3f840eb10af93c7c586f27e4513ec7876fc265a2d2cd3238b9c7d949a9b86f737da71de802d746a604d217ec5b6a9acab4d35e21fb388a276305e92e7e61f0af2c6313a23a71d0a71af76815f944463abfd6ac268590e96150d4c72c049222733dc2d43d676b02314b84a30c601a163a4e3bedc6d8c6d0523f955fe274ac3d788da7417b6f57c9341582adbaa8a40fc194e1e949ca5e2863c0dc3676451e69b13a2de5c06f238ce9712a08c1a834e34c62f567b43d525c28edabeb64d0c6183e039087b73bbf4c9de17d76a12d119b451781684e6b04fe1c82c29d51fe37ddd92fa0ae796556aacc658a78440aff7cee2ac18e1a3ba8358e34f86da57515b357e88311717ed46bd2fbac9000c0636c4744c674bd64f1a078a9e85b6f5aa247cae5a981157a6f3fb2a402cd2c723e2f353d19602ab02d20fc0009b7f392ea5a9ca0e862462a314fbd7c634be405b1e1ea588c570d55061a5b7360293cb865fa73002c83f60f959b6c6343d1ce2f4fb716e439cc9b567d9fed42b7908a6c3ef6200025039a625cffc024132a4e6162cfa43540d3507dc3495f5a264a53813402a2ae948ef98b4ee9ed670ccf596d0b316e9695af41eac617afa3769c04050a264aafe2b52a5f585ab16905430ac77180c25c6e6edfe35450e7458a5464b4c766e64163d69b21f58195aea1091ed39ffa35f1a283a5df4af7b04a77c927355636545af6c9870491e01bf690a9aad45fa006dfdd69b70a567d316a99a0ecf3677418f0a50a9d8981aed1ffb8d4d4bdccc079cb44bbe37fcbacb21509072a7d33de6de1c4a36c77fa2d09079a829625b98aec298089420eb8ced1cd95fb5883bcc7ded4cba2bb18779957c15de6bf5b5075900cb7e5451e795658625554303b245571ea2c1d44e2919dfb41e7b7fa71a4674c547debb7be623194a76b9f18a561b8722051c98b18a191ed665dbfa89e106e311f44c83f268bf871ddb2e97209bf1b49c883550819a90636a0ecb51a1de55af16688a11240b89bb9f549ed2aa623c7878cfabb00a342ee510241242f61da67158421d851df8e314df33112c7862b108c72a082b19718a4225fd2c2f26d26b1d40605f720d09ee787200615fce3d5492957b6f57e4a1cec16dba0b4ae858d48b3468d46e750b3f8ecbf88229b05b5f523984a7b6943fffaf7a837c311a802be7ed49216a67b67f1af2af8b0795bbde45f1a983775de4d8cde29edb6066fe06536cd889e2d6da652c8d5278d8c5653198c11ae8c7ed62a72ba81149419683a1dd5d15a8f651e3b10dba864efbe03354015c36641b0dcdbf9e8033aa2737a8e02cf1c367b068454907112945695c2c8fd98c0f807cae6c5bb37087eaa66788a6e0b3ba0ff3c68cf228373c77bc6fb5ab2a186caba7163f64c2618411516e9f51317bf3af6d9921867e6591bda258787fad65b4adcd7245ae8440a9b5b5b0a6d82ea1ef0d188d8fce60b3db133910553912e127634866684392619283afedce6146408a4234f7d2f30303659baf8b2d6060723a35f76f491a0cd3de17a460d755c8d7a41d4700f092b0a1f0e30421cadb7159a474bba059154174101301c772bf799e2a3d7867ee6197820a02fcd830493ffa5e053620cec97d7e77f217b61af8bb2bb71afa9d8dbe4cb032a98a2f7295ccd1235c8ce72c416747e339892ed5f0d28faa5181fb6d7bb1584a1598f141b8d2dd447204f08e0907b327cb695ee141ec7c752666a213209834f0d0214d55ebe4f353fc41e2c957d52b74047506d22fe9646c6df6e2d06182bbfb1bdd10980fb86abd58ff4ac0fe9ed58518c35027d6e4a289ae7a94093deda6fe8fb9c96227aa73299c93696ca011f65f03294d4fdc3ece9e8014a5924f54629d5fccdd450653922a5a699f6716ba72e8be72e0e40537861250f9ffab9d3c6d1ff1c70a62e7a4fffe86b09e41483ba0af4ff98fa85efe5ac8aa224829c41acc0f4f089dd870a9015c4b74decd6a78eaa31e400dd478579eea112a13a66390769f4049490d0fecc3d989f3a8be60c7f1aac0c3a0e83ecd2618f573edaa24c7cec1ac5a2b994baf7b7423f6df4987a8534cc0979c230fff1f9bc27963969846d103995e77744fd932f1e721c31af23327c45302faa0eff19addec5fcaded239886d4750a949728a3f343350b1e8eb5801af91227e0c79bf9feeb15ea778879785d19a660c704436397539d8af9c374a97cef2a780e6efba72ba1dc91bcea2c875bfbe97a1288aaab42494c09db98204316f5d0992f9fcc735fe65cc80bffb12190c9f1e26371e8ef1e823a0b51ee0e4d7f699cd2aaf468d7ea0dd2fb75398a34c6fc090db0aeb35ee1d70818569eb11384aa843e4adb1115a98b873c0a87dc48e9e70abdb6bff46054003fe06af0ca31abd193c59b18a6653b886493097e89c11f2d9800ae07c054a2003e097c1234ae471f8837d60bb5d4642f2dff71e6d798304530bb99134881a2dcaf7f245a9f0023cf443f9eba07a850e10ff1c9cba5df86f0d4ddcf8221ab5296eb864ac877b0deb6bfed64668a4e0ed928048019ad1a0f5c8b4a796b3664f2de69da29b7b3701fc5a2cde0bda9efa15796c6efa1874843c9fecaa294df3c0706102c104851f6e841953bda2991e2da116d1dd2401ed34a863018f10df375ec64ec72378ce2178252044b0b6f2ffa456b3cd72b1c719846eaae5323b4258df7d8a44e215d360724a723c54fe1b9fcfbe1c040a9f5129f0acb693a01269f31c7044d5fdffb63\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n"}]